/**
 * Authors: Arnaud Schils
 */

#include "mptcp.h"
#include "packet_to_string.h"

void init_mp_state()
{
	mp_state.packetdrill_key_set = false;
	mp_state.kernel_key_set = false;
	queue_init(&mp_state.vars_queue);
	queue_init_val(&mp_state.vals_queue);
	queue_init_val(&mp_state.script_only_vals_queue);
	mp_state.vars = NULL; //Init hashmap
	mp_state.idsn = UNDEFINED;
	mp_state.remote_idsn = UNDEFINED;
	mp_state.remote_ssn = 0;
	mp_state.remote_last_pkt_length = 0;
}

void free_mp_state(){
	free_var_queue();
	free_val_queue();
	free_vars();
	free_flows();
}

/**
 * Remember mptcp connection key generated by packetdrill. This key is needed
 * during the entire mptcp connection and is common among all mptcp subflows.
 */
void set_packetdrill_key(u64 sender_key)
{
	mp_state.packetdrill_key = sender_key;
	mp_state.packetdrill_key_set = true;
}

/**
 * Remember mptcp connection key generated by kernel. This key is needed
 * during the entire mptcp connection and is common among all mptcp subflows.
 */
void set_kernel_key(u64 receiver_key)
{
    mp_state.kernel_key = receiver_key;
    mp_state.kernel_key_set = true;
}

/* var_queue functions */

/**
 * Insert a COPY of name char* in mp_state.vars_queue.
 * Error is returned if queue is full.
 *
 */
int enqueue_var(char *name)
{
	unsigned name_length = strlen(name);
	char *new_el = malloc(sizeof(char)*name_length+1);
	memcpy(new_el, name, name_length);
	new_el[name_length] = '\0';
	int full_err = queue_enqueue(&mp_state.vars_queue, new_el);
	return full_err;
}

//Caller should free
int dequeue_var(char **name){
	int empty_err = queue_dequeue(&mp_state.vars_queue, (void**)name);
	return empty_err;
}

//Free all variables names (char*) in vars_queue
void free_var_queue()
{
	queue_free(&mp_state.vars_queue);
}

//Free all added values in vals_queue
void free_val_queue()
{
	queue_free_val(&mp_state.vals_queue);
}

/* hashmap functions */

void save_mp_var_name(char *name, struct mp_var *var)
{
	unsigned name_length = strlen(name);
	var->name = malloc(sizeof(char)*(name_length+1));
	memcpy(var->name, name, (name_length+1)); //+1 to copy '/0' too
}

/**
 *
 * Save a variable <name, value> in variables hashmap.
 * Where value is of u64 type key.
 *
 * Key memory location should stay valid, name is copied.
 *
 */
void add_mp_var_key(char *name, u64 *key)
{
	struct mp_var *var = malloc(sizeof(struct mp_var));
	save_mp_var_name(name, var);
	var->value = key;
	var->mptcp_subtype = MP_CAPABLE_SUBTYPE;
	var->mp_capable_info.script_defined = false;
	add_mp_var(var);
}

/**
 *
 * Save a variable <name, value> in variables hashmap.
 * Where value is of struct endpoint.
 *
 * Value is copied in a newly allocated pointer and will be freed when
 * free_vars function will be executed.
 *
 */
void add_mp_var_addr(char *name, struct endpoint *endpoint)
{
	struct mp_var *var = malloc(sizeof(struct mp_var));
	save_mp_var_name(name, var);
	var->value = malloc(sizeof(*endpoint));
	memcpy(var->value, endpoint, sizeof(*endpoint));
	var->mptcp_subtype = ADD_ADDR_SUBTYPE;
	add_mp_var(var);
}

/**
 * Save a variable <name, value> in variables hashmap.
 * Value is copied in a newly allocated pointer and will be freed when
 * free_vars function will be executed.
 *
 */
void add_mp_var_script_defined(char *name, void *value, u32 length)
{
	struct mp_var *var = malloc(sizeof(struct mp_var));
	save_mp_var_name(name, var);
	var->value = malloc(length);
	memcpy(var->value, value, length);
	var->mptcp_subtype = MP_CAPABLE_SUBTYPE;
	var->mp_capable_info.script_defined = true;
	add_mp_var(var);
}

/**
 * Add var to the variable hashmap.
 */
void add_mp_var(struct mp_var *var)
{
	HASH_ADD_KEYPTR(hh, mp_state.vars, var->name, strlen(var->name), var);
}

/**
 * Search in the hashmap for the value of the variable of name "name" and
 * return both variable - value (mp_var struct).
 * NULL is returned if not found
 */
struct mp_var *find_mp_var(char *name)
{
    struct mp_var *found;
    HASH_FIND_STR(mp_state.vars, name, found);
    return found;
}

/**
 * Gives next mptcp key value needed to insert variable values while processing
 * the packets.
 */
u64 *find_next_key(){
	char *var_name;
	if(dequeue_var(&var_name) || !var_name){
		return NULL;
	}

	struct mp_var *var = find_mp_var(var_name);
	free(var_name);
	if(!var || var->mptcp_subtype != MP_CAPABLE_SUBTYPE){
		return NULL;
	}
	return (u64*)var->value;
}

/**
 * Iterate through hashmap, free mp_var structs and mp_var->name.
 * Value is not freed for KEY type, since values come from stack.
 */
void free_vars()
{
	struct mp_var *next, *var;
	var = mp_state.vars;

	while(var){
		next = var->hh.next;
		free(var->name);
		if(var->mptcp_subtype == MP_CAPABLE_SUBTYPE){
			if(var->mp_capable_info.script_defined)
				free(var->value);
		}
		free(var);
		var = next;
	}
}

/**
 * Returns the next value entered in script (enqueud)
 */
u64 find_next_value(){
	u64 val;
	if(queue_dequeue_val(&mp_state.vals_queue, &val))
		return STATUS_ERR;
	return val;
}

void find_or_create_packetdrill_addr(u8 *address_id, struct ip_address **ip)
{
	// Find a unique address id and ip possibly needed for creation
	// TODO(malsbat): this assumes all packetdrill addresses are the same family
	u8 next_addr_id = 0;
	struct ip_address next_ip = {0};
	struct mp_address *addr;
	for(addr = mp_state.packetdrill_addrs; addr; addr = addr->next){
		if(addr->addr_id > next_addr_id)
			next_addr_id = addr->addr_id;
		if(addr->ip.address_family == AF_INET && addr->ip.ip.bytes[3] > next_ip.ip.bytes[3])
			next_ip = addr->ip;
		else if(addr->ip.address_family == AF_INET6 && addr->ip.ip.bytes[15] > next_ip.ip.bytes[15])
			 next_ip = addr->ip;
	}
	++next_addr_id;
	if(next_ip.address_family == AF_INET)
		++next_ip.ip.bytes[3];
	else
		++next_ip.ip.bytes[15];

	addr = NULL;
	if(mp_state.packetdrill_addrs == NULL){
		addr = malloc(sizeof(*addr));
		addr->addr_id = ((s8)*address_id == UNDEFINED) ? 0 : *address_id;
		assert(*ip);
		addr->ip = **ip;
		addr->next = mp_state.packetdrill_addrs;
		mp_state.packetdrill_addrs = addr;
	}else if((s8)*address_id == UNDEFINED && *ip == NULL){
		addr = malloc(sizeof(*addr));
		addr->addr_id = next_addr_id;
		addr->ip = next_ip;
		addr->next = mp_state.packetdrill_addrs;
		mp_state.packetdrill_addrs = addr;
	}else if((s8)*address_id != UNDEFINED && *ip == NULL){
		for(addr = mp_state.packetdrill_addrs; addr; addr = addr->next){
			if(addr->addr_id == *address_id)
				break;
		}
		if(addr == NULL){
			addr = malloc(sizeof(*addr));
			addr->addr_id = *address_id;
			addr->ip = next_ip;
			addr->next = mp_state.packetdrill_addrs;
			mp_state.packetdrill_addrs = addr;
		}
	}else if((s8)*address_id == UNDEFINED && *ip != NULL){
		for(addr = mp_state.packetdrill_addrs; addr; addr = addr->next){
			if(is_equal_ip(&addr->ip, *ip))
				break;
		}
		if(addr == NULL){
			addr = malloc(sizeof(*addr));
			addr->addr_id = next_addr_id;
			addr->ip = **ip;
			addr->next = mp_state.packetdrill_addrs;
			mp_state.packetdrill_addrs = addr;
		}
	}else{
		assert((s8)*address_id != UNDEFINED && *ip != NULL);
		for(addr = mp_state.packetdrill_addrs; addr; addr = addr->next){
			if((addr->addr_id == *address_id) && is_equal_ip(&addr->ip, *ip))
				break;
		}
		if(addr == NULL){
			addr = malloc(sizeof(*addr));
			addr->addr_id = *address_id;
			addr->ip = **ip;
			addr->next = mp_state.packetdrill_addrs;
			mp_state.packetdrill_addrs = addr;
		}
	}
	*address_id = addr->addr_id;
	*ip = &addr->ip;
}

/**
 * @pre inbound packet should be the first packet of a three-way handshake
 * mp_join initiated by packetdrill (thus an inbound mp_join syn packet).
 *
 * @post
 * - Create a new subflow structure containing all available information at this
 * time (src_ip, dst_ip, src_port, dst_port, packetdrill_rand_nbr,
 * packetdrill_addr_id). kernel_addr_id and kernel_rand_nbr should be set when
 * receiving syn+ack with mp_join mptcp option from kernel.
 */
struct mp_subflow *new_subflow_inbound(struct packet *inbound_packet)
{

	struct mp_subflow *subflow = malloc(sizeof(struct mp_subflow));

	if(inbound_packet->ipv4){
		ip_from_ipv4(&inbound_packet->ipv4->src_ip, &subflow->src_ip);
		ip_from_ipv4(&inbound_packet->ipv4->dst_ip, &subflow->dst_ip);
	}

	else if(inbound_packet->ipv6){
		ip_from_ipv6(&inbound_packet->ipv6->src_ip, &subflow->src_ip);
		ip_from_ipv6(&inbound_packet->ipv6->dst_ip, &subflow->dst_ip);
	}

	else{
		return NULL;
	}

	subflow->src_port = ntohs(inbound_packet->tcp->src_port);
	subflow->dst_port = ntohs(inbound_packet->tcp->dst_port);
	subflow->packetdrill_rand_nbr =	42;
	subflow->packetdrill_addr_id = UNDEFINED;
	struct ip_address *ip = &subflow->src_ip;
	find_or_create_packetdrill_addr(&subflow->packetdrill_addr_id, &ip);
	subflow->ssn = 1; // =1 because the code assumes it is being set with the third ack,
			  // although that is not the case anymore (new_subflow_inbound is also
			  // called at syn time)
//	subflow->state = UNDEFINED;  // TODO to define it and change the state after
	subflow->next = mp_state.subflows;
	mp_state.subflows = subflow;

	return subflow;
}

struct mp_subflow *new_subflow_outbound(struct packet *outbound_packet)
{

	struct mp_subflow *subflow = malloc(sizeof(struct mp_subflow));
	struct tcp_option *mp_join_syn =
			get_mptcp_option(outbound_packet, MP_CAPABLE_SUBTYPE); //TCPOPT_MPTCP);

	if(!mp_join_syn)
		return NULL;

	if(outbound_packet->ipv4){
		ip_from_ipv4(&outbound_packet->ipv4->dst_ip, &subflow->src_ip);
		ip_from_ipv4(&outbound_packet->ipv4->src_ip, &subflow->dst_ip);
	}

	else if(outbound_packet->ipv6){
		ip_from_ipv6(&outbound_packet->ipv6->dst_ip, &subflow->src_ip);
		ip_from_ipv6(&outbound_packet->ipv6->src_ip, &subflow->dst_ip);
	}

	else{
		return NULL;
	}

	subflow->src_port = ntohs(outbound_packet->tcp->dst_port);
	subflow->dst_port = ntohs(outbound_packet->tcp->src_port);
	subflow->kernel_rand_nbr =
			mp_join_syn->data.mp_join.syn.no_ack.sender_random_number;
	subflow->kernel_addr_id =
			mp_join_syn->data.mp_join.syn.address_id;
	subflow->packetdrill_addr_id = UNDEFINED;
	struct ip_address *ip = &subflow->src_ip;
	find_or_create_packetdrill_addr(&subflow->packetdrill_addr_id, &ip);
	subflow->ssn = 1;
	subflow->next = mp_state.subflows;
	mp_state.subflows = subflow;
	return subflow;
}

/**
 * Return the first subflow S of mp_state.subflows for which match(packet, S)
 * returns true.
 */
struct mp_subflow *find_matching_subflow(struct packet *packet,
		bool (*match)(struct mp_subflow*, struct packet*))
{
	struct mp_subflow *subflow = mp_state.subflows;
	while(subflow){
		if((*match)(subflow, packet)){
			return subflow;
		}
		subflow = subflow->next;
	}
	return NULL;
}

static bool does_subflow_match_outbound_packet(struct mp_subflow *subflow,
		struct packet *outbound_packet){
	return subflow->dst_port == ntohs(outbound_packet->tcp->src_port) &&
			subflow->src_port == ntohs(outbound_packet->tcp->dst_port);
}

struct mp_subflow *find_subflow_matching_outbound_packet(
		struct packet *outbound_packet)
{
	return find_matching_subflow(outbound_packet, does_subflow_match_outbound_packet);
}

static bool does_subflow_match_inbound_packet(struct mp_subflow *subflow,
		struct packet *inbound_packet){
	return subflow->dst_port == ntohs(inbound_packet->tcp->dst_port) &&
			subflow->src_port == ntohs(inbound_packet->tcp->src_port);
}

struct mp_subflow *find_subflow_matching_inbound_packet(
		struct packet *inbound_packet)
{
	return find_matching_subflow(inbound_packet, does_subflow_match_inbound_packet);
}

struct mp_subflow *find_subflow_matching_socket(struct socket *socket){
	struct mp_subflow *subflow = mp_state.subflows;
	while(subflow){
		if(subflow->dst_port == socket->live.remote.port &&
				subflow->src_port == socket->live.local.port){
			return subflow;
		}
		subflow = subflow->next;
	}
	return NULL;
}

/**
 * Free all mptcp subflows struct being a member of mp_state.subflows list.
 */
void free_flows(){
	struct mp_subflow *subflow = mp_state.subflows;
	struct mp_subflow *temp;
	while(subflow){
		temp = subflow->next;
		free(subflow);
		subflow = temp;
	}
}

/**
 * Generate a mptcp packetdrill side key and save it for later reference in
 * the script.
 *
 */
int mptcp_gen_key()
{

	//Retrieve variable name parsed by bison.
	char *snd_var_name;
	if(queue_front(&mp_state.vars_queue, (void**)&snd_var_name))
		return STATUS_ERR;

	//Is that var has already a value assigned in the script by user, or should
	//we generate a mptcp key ourselves?
	struct mp_var *snd_var = find_mp_var(snd_var_name);

	if(snd_var && snd_var->mptcp_subtype == MP_CAPABLE_SUBTYPE &&
			snd_var->mp_capable_info.script_defined)
		set_packetdrill_key(*(u64*)snd_var->value);

	//First inbound mp_capable, generate new key
	//and save corresponding variable
	if(!mp_state.packetdrill_key_set){
		seed_generator();
		u64 key = rand_64();
		set_packetdrill_key(key);
		add_mp_var_key(snd_var_name, &mp_state.packetdrill_key);
	}

	return STATUS_OK;
}

/**
 * Insert key field value of mp_capable_syn mptcp option according to variable
 * specified in user script.
 *
 */
int mptcp_set_mp_cap_syn_key(struct tcp_option *tcp_opt)
{
	u64 *key = find_next_key();
	if(!key)
		return STATUS_ERR;
	tcp_opt->data.mp_capable.syn.key = *key;
	return STATUS_OK;
}

/**
 * Insert keys fields values of mp_capable mptcp option according to variables
 * specified in user script.
 */
int mptcp_set_mp_cap_keys(struct tcp_option *tcp_opt)
{
	u64 *key = find_next_key();
	if(!key)
		return STATUS_ERR;
	tcp_opt->data.mp_capable.no_syn.sender_key = *key;

	key = find_next_key();
	if(!key)
		return STATUS_ERR;
	tcp_opt->data.mp_capable.no_syn.receiver_key = *key;
	return STATUS_OK;
}

/**
 * Extract mptcp connection informations from mptcp packets sent by kernel.
 * (For example kernel mptcp key).
 */
static int extract_and_set_kernel_key(
		struct packet *live_packet)
{

	struct tcp_option* mpcap_opt =
			get_tcp_option(live_packet, TCPOPT_MPTCP);

	if(!mpcap_opt)
		return STATUS_ERR;

	//Check if kernel key hasn't been specified by user in script
	char *var_name;
	if(!queue_front(&mp_state.vars_queue, (void**)&var_name)){
		struct mp_var *var = find_mp_var(var_name);
		if(var && var->mptcp_subtype == MP_CAPABLE_SUBTYPE &&
				var->mp_capable_info.script_defined)
			set_kernel_key(*(u64*)var->value);
	}

	if(!mp_state.kernel_key_set){

		//Set found kernel key
		set_kernel_key(mpcap_opt->data.mp_capable.syn.key);
		//Set front queue variable name to refer to kernel key
		char *var_name;
		if(queue_front(&mp_state.vars_queue, (void**)&var_name)){
			return STATUS_ERR;
		}
		add_mp_var_key(var_name, &mp_state.kernel_key);
	}

	return STATUS_OK;
}

/**
 * Insert appropriate key in mp_capable mptcp option.
 */
int mptcp_subtype_mp_capable(struct packet *packet_to_modify,
		struct packet *live_packet,
		struct tcp_option *tcp_opt_to_modify,
		unsigned direction)
{
	int error, optlen = tcp_opt_to_modify->length;

	// Syn packet, packetdrill -> kernel, v0
	if (optlen == TCPOLEN_MP_CAPABLE_SYN &&
	    direction == DIRECTION_INBOUND &&
	    !packet_to_modify->tcp->ack) {
		error = mptcp_gen_key();
		error = mptcp_set_mp_cap_syn_key(tcp_opt_to_modify) || error;
		// For inbound flow, initialise flow at syn,
		// For outbound flow, initialise at third ack.
		new_subflow_inbound(packet_to_modify);
	}
	// syn packet, inbound, v1
	else if (optlen == TCPOLEN_MP_CAPABLE_V1_SYN &&
		 direction == DIRECTION_INBOUND &&
		 !packet_to_modify->tcp->ack) {
		new_subflow_inbound(packet_to_modify);
		error = 0;
	}
	// Syn v0 and Syn_ack kernel->packetdrill
	else if (optlen == TCPOLEN_MP_CAPABLE_SYN &&
		 direction == DIRECTION_OUTBOUND) {
		error = extract_and_set_kernel_key(live_packet);
		error = mptcp_set_mp_cap_syn_key(tcp_opt_to_modify);
		mp_state.remote_ssn++;
	}
	// syn v1
	else if (optlen == TCPOLEN_MP_CAPABLE_V1_SYN &&
		 direction == DIRECTION_OUTBOUND) {
		error = 0;
	}
	// Third (ack) packet in three-hand shake
	else if (optlen == TCPOLEN_MP_CAPABLE ||
		 optlen == TCPOLEN_MP_CAPABLE_DATA) {
		/* with protocol v1, the client key is transmitted in
		 * the last packet of the three-way-handshake
		 */
		if (direction == DIRECTION_OUTBOUND &&
		    tcp_opt_to_modify->data.mp_capable.version != 0)
			error = extract_and_set_kernel_key(live_packet);
		if (direction == DIRECTION_INBOUND &&
		    tcp_opt_to_modify->data.mp_capable.version != 0)
			error = mptcp_gen_key();

		switch (tcp_opt_to_modify->data.mp_capable.version) {
			case MPTCPV0:
				mp_state.hash = HASH_ALGO_SHA1;
				break;
			case MPTCPV1:
				mp_state.hash = HASH_ALGO_SHA256;
				break;
			default:
				break;
		}

		error = mptcp_set_mp_cap_keys(tcp_opt_to_modify);
		// Automatically put the idsn tokens
		mp_state.idsn = sha_least_64bits(mp_state.packetdrill_key,
						 mp_state.hash);
		mp_state.remote_idsn = sha_least_64bits(mp_state.kernel_key,
							mp_state.hash);
		// If this is done at syn packet time as for inbound, key comparisons fail
		// due to, I guess, key set too early as it complains key is not 0
		if (optlen == TCPOLEN_MP_CAPABLE_DATA) {
			/* TODO update SSN counters */
		} else if (direction == DIRECTION_OUTBOUND) {
			new_subflow_outbound(live_packet);
		}
	}
	// SYN_ACK, packetdrill->kernel
	else if (tcp_opt_to_modify->length == TCPOLEN_MP_CAPABLE_SYN &&
		 direction == DIRECTION_INBOUND &&
		 packet_to_modify->tcp->ack) {
		error = mptcp_gen_key();
		error = mptcp_set_mp_cap_syn_key(tcp_opt_to_modify) || error;
	} else {
		return STATUS_ERR;
	}
	return error;
}

/**
 * Set appropriate receiver token value in tcp_option.
 *
 */
static void mp_join_syn_rcv_token(struct tcp_option *tcp_opt_to_modify,
		struct mp_join_info *mp_join_script_info,
		unsigned direction)
{
	if(mp_join_script_info->syn_or_syn_ack.is_script_defined){

		if(mp_join_script_info->syn_or_syn_ack.is_var){
			struct mp_var *var = find_mp_var(mp_join_script_info->syn_or_syn_ack.var);
			tcp_opt_to_modify->data.mp_join.syn.no_ack.receiver_token =
					htonl(sha1_least_32bits(*(u64*)var->value));
		}
		else{
			tcp_opt_to_modify->data.mp_join.syn.no_ack.receiver_token =
					htonl(mp_join_script_info->syn_or_syn_ack.hash);
		}
	}
	else if(direction == DIRECTION_INBOUND){
		tcp_opt_to_modify->data.mp_join.syn.no_ack.receiver_token =
				htonl(sha1_least_32bits(mp_state.kernel_key));
	}
	else if(direction == DIRECTION_OUTBOUND){
		tcp_opt_to_modify->data.mp_join.syn.no_ack.receiver_token =
				htonl(sha1_least_32bits(mp_state.packetdrill_key));
	}
}

static void mp_join_syn_address_id(struct tcp_option *tcp_opt_to_modify,
		struct mp_join_info *mp_join_script_info,
		struct mp_subflow *subflow,
		unsigned direction)
{
	if(mp_join_script_info->syn_or_syn_ack.address_id_script_defined){
		u8 script_addr_id = mp_join_script_info->syn_or_syn_ack.address_id;
		if(direction == DIRECTION_INBOUND )
			subflow->packetdrill_addr_id = script_addr_id;
		else
			subflow->kernel_addr_id = script_addr_id;
	}
	if(direction == DIRECTION_INBOUND){
		tcp_opt_to_modify->data.mp_join.syn.address_id =
				subflow->packetdrill_addr_id;
	}
	else if(direction == DIRECTION_OUTBOUND){
		tcp_opt_to_modify->data.mp_join.syn.address_id =
				subflow->kernel_addr_id;
	}
}

static void mp_join_syn_rand(struct tcp_option *tcp_opt_to_modify,
		struct mp_join_info *mp_join_script_info,
		struct mp_subflow *subflow,
		unsigned direction)
{
	//Set sender random number value
	if(mp_join_script_info->syn_or_syn_ack.rand_script_defined){
		u32 script_rand = mp_join_script_info->syn_or_syn_ack.rand;
		if(direction == DIRECTION_INBOUND)
			subflow->packetdrill_rand_nbr = script_rand;
		else
			subflow->kernel_rand_nbr = script_rand;
	}
	if(direction == DIRECTION_INBOUND){
		tcp_opt_to_modify->data.mp_join.syn.no_ack.sender_random_number =
				subflow->packetdrill_rand_nbr;
	}
	else if(direction == DIRECTION_OUTBOUND){
		tcp_opt_to_modify->data.mp_join.syn.no_ack.sender_random_number =
				htonl(subflow->kernel_rand_nbr);
	}
}

/**
 * Manage the case when packetdrill send a mp_join_syn to the kernel.
 *
 */
static int mp_join_syn(struct packet *packet_to_modify,
		struct packet *live_packet,
		struct tcp_option *tcp_opt_to_modify,
		struct mp_join_info *mp_join_script_info,
		unsigned direction)
{
	struct mp_subflow *subflow;
	if(direction == DIRECTION_INBOUND)
		subflow = new_subflow_inbound(packet_to_modify);
	else if(direction == DIRECTION_OUTBOUND)
		subflow = new_subflow_outbound(live_packet);
	if(!subflow)
		return STATUS_ERR;

	mp_join_syn_rcv_token(tcp_opt_to_modify, mp_join_script_info, direction);
	mp_join_syn_rand(tcp_opt_to_modify,
			mp_join_script_info,
			subflow,
			direction);
	mp_join_syn_address_id(tcp_opt_to_modify,
			mp_join_script_info,
			subflow,
			direction);

	return STATUS_OK;
}

void mp_join_syn_ack_sender_hmac(struct tcp_option *tcp_opt_to_modify,
		u64 key1, u64 key2, u32 msg1, u32 msg2)
{
	//Build key for HMAC-SHA1
	unsigned char hmac_key[16];
	unsigned long *key_a = (unsigned long*)hmac_key;
	unsigned long *key_b = (unsigned long*)&(hmac_key[8]);
	*key_a = key1;
	*key_b = key2;

	//Build message for HMAC-SHA1
	u32 msg[2];
	msg[0] = msg1;
	msg[1] = msg2;
	tcp_opt_to_modify->data.mp_join.syn.ack.sender_hmac =
			htobe64(hmac_sha1_truncat_64(hmac_key,
					16,
					(u8 *)msg,
					8));
}

static int mp_join_syn_ack(struct packet *packet_to_modify,
		struct packet *live_packet,
		struct tcp_option *tcp_opt_to_modify,
		struct mp_join_info *mp_join_script_info,
		unsigned direction)
{
	if(direction == DIRECTION_INBOUND){
		struct mp_subflow *subflow =
				find_subflow_matching_inbound_packet(packet_to_modify);

		if(!subflow)
			return STATUS_ERR;

		subflow->packetdrill_rand_nbr = generate_32();

		mp_join_syn_address_id(tcp_opt_to_modify,
				mp_join_script_info,
				subflow,
				direction);

		if(mp_join_script_info->syn_or_syn_ack.rand_script_defined)
			subflow->packetdrill_rand_nbr =
					mp_join_script_info->syn_or_syn_ack.rand;

		tcp_opt_to_modify->data.mp_join.syn.ack.sender_random_number =
				htonl(subflow->packetdrill_rand_nbr);

		if(mp_join_script_info->syn_or_syn_ack.is_script_defined){
			if(mp_join_script_info->syn_or_syn_ack.is_var){
				struct mp_var *var =
						find_mp_var(mp_join_script_info->syn_or_syn_ack.var);
				struct mp_var *var2 =
						find_mp_var(mp_join_script_info->syn_or_syn_ack.var2);
				mp_join_syn_ack_sender_hmac(tcp_opt_to_modify,
									*(u64*)var->value,
									*(u64*)var2->value,
									subflow->packetdrill_rand_nbr,
									subflow->kernel_rand_nbr);

			}
		}
		else{
			mp_join_syn_ack_sender_hmac(tcp_opt_to_modify,
					mp_state.packetdrill_key,
					mp_state.kernel_key,
					subflow->packetdrill_rand_nbr,
					subflow->kernel_rand_nbr);
		}
	}

	else if(direction == DIRECTION_OUTBOUND){
		struct mp_subflow *subflow =
				find_subflow_matching_outbound_packet(live_packet);
		struct tcp_option *live_mp_join =
				get_tcp_option(live_packet, TCPOPT_MPTCP);

		if(!subflow || !live_mp_join)
			return STATUS_ERR;

		//Update mptcp packetdrill state
		subflow->kernel_addr_id =
				live_mp_join->data.mp_join.syn.address_id;
		subflow->kernel_rand_nbr =
				live_mp_join->data.mp_join.syn.ack.sender_random_number;

		//Build key for HMAC-SHA1
		unsigned char hmac_key[16];
		unsigned long *key_b = (unsigned long*)hmac_key;
		unsigned long *key_a = (unsigned long*)&(hmac_key[8]);
		*key_b = mp_state.kernel_key;
		*key_a = mp_state.packetdrill_key;

		//Build message for HMAC-SHA1
		unsigned msg[2];
		msg[0] = subflow->kernel_rand_nbr;
		msg[1] = subflow->packetdrill_rand_nbr;

		//Update script packet mp_join option fields
		tcp_opt_to_modify->data.mp_join.syn.address_id =
				live_mp_join->data.mp_join.syn.address_id;
		tcp_opt_to_modify->data.mp_join.syn.ack.sender_random_number =
				live_mp_join->data.mp_join.syn.ack.sender_random_number;
		tcp_opt_to_modify->data.mp_join.syn.ack.sender_hmac =
				hmac_sha1_truncat_64(hmac_key, 16, (u8*)msg, 8);
	}
	return STATUS_OK;
}
/**
 * Update mptcp subflows state according to sent/sniffed mp_join packets.
 * Insert appropriate values retrieved from this up-to-date state in inbound
 * and outbound packets.
 */
int mptcp_subtype_mp_join(struct packet *packet_to_modify,
						struct packet *live_packet,
						struct tcp_option *tcp_opt_to_modify,
						unsigned direction)
{
	struct mp_join_info *mp_join_script_info;
	if(queue_dequeue(&mp_state.vars_queue, (void**)&mp_join_script_info))
		return STATUS_ERR;

	if(direction == DIRECTION_INBOUND &&
			!packet_to_modify->tcp->ack &&
			packet_to_modify->tcp->syn &&
			tcp_opt_to_modify->length == TCPOLEN_MP_JOIN_SYN){

		mp_join_syn(packet_to_modify,
				live_packet,
				tcp_opt_to_modify,
				mp_join_script_info,
				DIRECTION_INBOUND);
	}
	else if(direction == DIRECTION_OUTBOUND &&
			packet_to_modify->tcp->ack &&
			packet_to_modify->tcp->syn &&
			tcp_opt_to_modify->length == TCPOLEN_MP_JOIN_SYN_ACK){

		struct mp_subflow *subflow =
				find_subflow_matching_outbound_packet(live_packet);
		struct tcp_option *live_mp_join =
				get_tcp_option(live_packet, TCPOPT_MPTCP);

		if(!subflow || !live_mp_join)
			return STATUS_ERR;

		//Update mptcp packetdrill state
		subflow->kernel_addr_id =
				live_mp_join->data.mp_join.syn.address_id;
		subflow->kernel_rand_nbr =
				live_mp_join->data.mp_join.syn.ack.sender_random_number;

		//Update script packet mp_join option fields
		tcp_opt_to_modify->data.mp_join.syn.address_id =
				live_mp_join->data.mp_join.syn.address_id;
		tcp_opt_to_modify->data.mp_join.syn.ack.sender_random_number =
				live_mp_join->data.mp_join.syn.ack.sender_random_number;

		//Build key for HMAC-SHA1
		u64 loc_key = mp_state.packetdrill_key;
		u64 rem_key = mp_state.kernel_key;
		u32 loc_nonce = subflow->packetdrill_rand_nbr;
		u32 rem_nonce = live_mp_join->data.mp_join.syn.ack.sender_random_number;

		// return value
		u8 mptcp_hash_mac[20];
		mptcp_hmac_sha1(
				(u8*)&rem_key,
				(u8*)&loc_key,
				(u8*)&rem_nonce,
				(u8*)&loc_nonce,
				(u32*)mptcp_hash_mac );

//		u64 live_hmac = live_mp_join->data.mp_join.syn.ack.sender_hmac;
//		printf("822: %llu == %llu\n", live_hmac, *(u64*)mptcp_hash_mac );

		tcp_opt_to_modify->data.mp_join.syn.ack.sender_hmac = *(u64*)mptcp_hash_mac;
	}
	//mp_join ack XXX
	else if(direction == DIRECTION_INBOUND &&
			packet_to_modify->tcp->ack &&
			!packet_to_modify->tcp->syn &&
			tcp_opt_to_modify->length == TCPOLEN_MP_JOIN_ACK){
		struct mp_subflow *subflow = find_subflow_matching_inbound_packet(packet_to_modify);
		if(!subflow)
			return STATUS_ERR;

		if(mp_join_script_info->ack.is_var){
			//Build key for HMAC-SHA1
			u64 loc_key = mp_state.packetdrill_key;
			u64 rem_key = mp_state.kernel_key;
			u32 loc_nonce = subflow->packetdrill_rand_nbr;
			u32 rem_nonce = subflow->kernel_rand_nbr;

			// return value
			u8 mptcp_hash_mac[20];
			mptcp_hmac_sha1(
					(u8*)&loc_key,
					(u8*)&rem_key,
					(u8*)&loc_nonce,
					(u8*)&rem_nonce,
					(u32*)mptcp_hash_mac );

			memcpy(tcp_opt_to_modify->data.mp_join.no_syn.sender_hmac,
					mptcp_hash_mac,
					20);
		}else if(mp_join_script_info->ack.is_script_defined){
			char *key_1 = mp_join_script_info->ack.var;
			char *key_2 = mp_join_script_info->ack.var2;

			struct mp_var *var1 = find_mp_var(key_1);
			struct mp_var *var2 = find_mp_var(key_2);
			if(var1==NULL || var2==NULL)
				return STATUS_ERR;
			u64 loc_key = *(u64*)var1->value;
			u64 rem_key = *(u64*)var2->value;
			u32 loc_nonce = subflow->packetdrill_rand_nbr;
			u32 rem_nonce = subflow->kernel_rand_nbr;
			// return value
			u8 mptcp_hash_mac[20];
			mptcp_hmac_sha1(
					(u8*)&loc_key,
					(u8*)&rem_key,
					(u8*)&loc_nonce,
					(u8*)&rem_nonce,
					(u32*)mptcp_hash_mac );

			memcpy(tcp_opt_to_modify->data.mp_join.no_syn.sender_hmac,
					mptcp_hash_mac,
					20);
		}else{
			return STATUS_ERR;
		}
	}

	else if(direction == DIRECTION_OUTBOUND &&
			!packet_to_modify->tcp->ack &&
			packet_to_modify->tcp->syn &&
			tcp_opt_to_modify->length == TCPOLEN_MP_JOIN_SYN){

		mp_join_syn(packet_to_modify,
				live_packet,
				tcp_opt_to_modify,
				mp_join_script_info,
				DIRECTION_OUTBOUND);
	}

	else if(direction == DIRECTION_INBOUND &&
			packet_to_modify->tcp->ack &&
			packet_to_modify->tcp->syn &&
			tcp_opt_to_modify->length == TCPOLEN_MP_JOIN_SYN_ACK){

		mp_join_syn_ack(packet_to_modify,
				live_packet,
				tcp_opt_to_modify,
				mp_join_script_info,
				DIRECTION_INBOUND);
	}

	else if(direction == DIRECTION_OUTBOUND &&
			packet_to_modify->tcp->ack &&
			!packet_to_modify->tcp->syn &&
			tcp_opt_to_modify->length == TCPOLEN_MP_JOIN_ACK){

		struct mp_subflow *subflow =
				find_subflow_matching_outbound_packet(packet_to_modify);

		if(!subflow)
			return STATUS_ERR;

		//Build key for HMAC-SHA1
		u64 loc_key = mp_state.packetdrill_key;
		u64 rem_key = mp_state.kernel_key;
		u32 loc_nonce = subflow->packetdrill_rand_nbr;
		u32 rem_nonce = subflow->kernel_rand_nbr;

		// return value
		u8 mptcp_hash_mac[20];
		mptcp_hmac_sha1(
				(u8*)&rem_key,
				(u8*)&loc_key,
				(u8*)&rem_nonce,
				(u8*)&loc_nonce,
				(u32*)mptcp_hash_mac );

		memcpy(tcp_opt_to_modify->data.mp_join.no_syn.sender_hmac,
				mptcp_hash_mac, 20);
	}
	else{
		return STATUS_ERR;
	}
	return STATUS_OK;
}

//Compute tcp payload length
u16 get_tcp_payload_size(struct packet *packet){
	u16 packet_total_length = packet->ip_bytes;
	u16 tcp_header_length = packet->tcp->doff*4;
	u16 ip_header_length = packet->ipv4->ihl*8;
	u16 tcp_header_wo_options = 20;
	return (packet_total_length-ip_header_length-
			(tcp_header_length-tcp_header_wo_options));
}
u32 get_sum_ssn(){
	struct mp_subflow *mp_sub = mp_state.subflows;
	u32 total_length = 1; // first subflow has already one packet sent
	while(mp_sub != NULL){
		total_length += mp_sub->ssn -1;
		mp_sub = mp_sub->next;
	}
	return total_length;
}

u16 get_tcp_header_length(struct packet *packet){
	return  packet->tcp->doff*4 + 20; // tcp_header_wo_options = 20
}

static int set_dack4(struct dack *dack_live, struct dack *dack_script)
{
	if(dack_script->dack4 == UNDEFINED)
		dack_live->dack4 = htobe32(mp_state.remote_idsn + mp_state.remote_ssn + mp_state.remote_last_pkt_length);
	else if(dack_script->dack4 == SCRIPT_DEFINED_TO_HASH_LSB){
		u64 additional_val 	= find_next_value();
		u64 *key = find_next_key();
		if(!key || additional_val==STATUS_ERR)
			return STATUS_ERR;
		dack_live->dack4 =
			htobe32(sha_least_64bits(*key,
					         mp_state.hash) +
			        additional_val);
	}else{
		if (dack_script->dack4 > 0)
			dack_live->dack4 =
				htobe32(sha_least_64bits(mp_state.kernel_key,
						         mp_state.hash) +
				        dack_script->dack4);
		else
			return STATUS_ERR;
	}
	return STATUS_OK;
}

static int set_dack8(struct dack *dack_live, struct dack *dack_script)
{
	if(dack_script->dack8 == UNDEFINED)
		dack_live->dack8 = htonll(mp_state.remote_idsn + mp_state.remote_ssn);
	else if(dack_script->dack8 == SCRIPT_DEFINED_TO_HASH_LSB){
		u64 additional_val 	= find_next_value();
		u64 *key = find_next_key();
		if(!key || additional_val==STATUS_ERR)
			return STATUS_ERR;
		dack_live->dack8 =
			htonll(sha_least_64bits(*key,
						mp_state.hash) +
			       additional_val);
	}else{
		if (dack_script->dack8 > 0)
			dack_live->dack8 =
				htonll(sha_least_64bits(mp_state.kernel_key,
						        mp_state.hash) +
				       dack_script->dack8);
	}
	return STATUS_OK;
}

static int set_dsn4(struct dsn *dsn_live, struct dsn *dsn_script)
{
	u32 bytes_sent_on_all_ssn = get_sum_ssn();
	if(dsn_script->dsn4 == UNDEFINED){
		dsn_live->dsn4 = htonl(mp_state.idsn + bytes_sent_on_all_ssn);
	}else if(dsn_script->dsn4 == SCRIPT_DEFINED_TO_HASH_LSB){
		u64 additional_val 	= find_next_value();
		u64 *key = find_next_key();
		if(!key || additional_val==STATUS_ERR)
			return STATUS_ERR;
		dsn_live->dsn4 = htonl(sha_least_64bits(*key,
							mp_state.hash) +
				       additional_val);
	}else{
		if (dsn_script->dsn4 > 0)
			dsn_live->dsn4 =
				htonl(sha_least_64bits(mp_state.packetdrill_key,
						       mp_state.hash) +
				      dsn_script->dsn4);
	}
        return STATUS_OK;
}

static int set_dsn8(struct dsn *dsn_live, struct dsn *dsn_script)
{
	u32 bytes_sent_on_all_ssn = get_sum_ssn();
	if(dsn_script->dsn8 == UNDEFINED)
		dsn_live->dsn8 = htonll(mp_state.idsn + bytes_sent_on_all_ssn);
	else if(dsn_script->dsn8 == SCRIPT_DEFINED_TO_HASH_LSB){
		u64 additional_val 	= find_next_value();
		u64 *key = find_next_key();
		if(!key || additional_val==STATUS_ERR)
			return STATUS_ERR;
		dsn_live->dsn8 =
			htonll(sha_least_64bits(*key, mp_state.hash) +
			       additional_val);
	}else{
		if (dsn_script->dsn8 > 0)
			dsn_live->dsn8 =
				htonll(sha_least_64bits(mp_state.packetdrill_key,
						        mp_state.hash) +
				       dsn_script->dsn8);
	}
        return STATUS_OK;
}

static void set_ssn_dll_cs(u32* ssn_live, u64 dsn, u32 ssn, u16 dll, bool with_checksum)
{
	*ssn_live = *ssn_live == UNDEFINED ? htonl(ssn): htonl(*ssn_live);

	u16 *dll_live = (u16*)(ssn_live+1);
	*dll_live = (s16)*(dll_live) == UNDEFINED ? htons(dll): htons(*(dll_live));

	if(with_checksum){
		//Compute checksum
		struct {
			u64 dsn;
			u32 ssn;
			u16 dll;
			u16 zeros;
		} __packed buff_chk;

		buff_chk.dsn = dsn;
		buff_chk.ssn = ntohl(*ssn_live);
		buff_chk.dll = ntohs(*dll_live);
		buff_chk.zeros = (u16)0;

		// checksum
		*(dll_live+1) = (s16)*(dll_live+1) == UNDEFINED ? htons(checksum_dss((u16*)&buff_chk, sizeof(buff_chk))): *(dll_live+1);
	}
}

/**
 *  It will parse an inbound packet and modify the script packet
 *  in order to correspond with the scripted tests.
 */
int dss_inbound_parser(struct packet *packet_to_modify,
		struct packet *live_packet,
		struct tcp_option *dss_opt_script){
	struct mp_subflow *subflow = find_subflow_matching_inbound_packet(packet_to_modify);
	if(!subflow){
		printf("May-be not a MPTCP connection : no subflow found --- \n");
		return STATUS_ERR;
	}

	u16 tcp_payload_length = (u16)packet_payload_len(packet_to_modify);

	// add +1 to tcp_payload if FIN falg is set
	if(dss_opt_script->data.dss.flag_F)
		tcp_payload_length++;

	struct tcp_option* dss_opt_live = get_tcp_option(live_packet, TCPOPT_MPTCP);
	if(!dss_opt_live)
		return STATUS_ERR;
	// if a packet is going from packetdrill with DSN and DACK to kernel
	if(dss_opt_script->data.dss.flag_M && dss_opt_script->data.dss.flag_A){
		// DSN4 & DACK4
		if(!dss_opt_script->data.dss.flag_m && !dss_opt_script->data.dss.flag_a){

			// get original information from live_packet
			struct dack *dack_live	= (struct dack*)((u32*)dss_opt_live+1);
			struct dsn *dsn_live 	= (struct dsn*) ((u32*)dss_opt_live+2);
			u32* ssn_live           = (u32*)dsn_live+1;
			struct dack *dack_script= (struct dack*)((u32*)dss_opt_script+1);
			struct dsn *dsn_script	= (struct dsn*) ((u32*)dss_opt_script+2);

			set_dack4(dack_live, dack_script);
			set_dsn4(dsn_live, dsn_script);
			set_ssn_dll_cs(ssn_live,
			               ((mp_state.idsn >>32)<<32) + ntohl(dsn_live->dsn4),
			               subflow->ssn,
			               tcp_payload_length,
			               dss_opt_script->length == TCPOLEN_DSS_DACK4_DSN4);

		// DSN4 & DACK8
		}else if(!dss_opt_script->data.dss.flag_m && dss_opt_script->data.dss.flag_a){
			// get original information from live_packet
			struct dack *dack_live	= (struct dack*)((u32*)dss_opt_live+1);
			struct dsn *dsn_live 	= (struct dsn*)((u32*)dss_opt_live+3);
			u32* ssn_live           = (u32*)dsn_live+1;
			struct dack *dack_script= (struct dack*)((u32*)dss_opt_script+1);
			struct dsn *dsn_script	= (struct dsn*)((u32*)dss_opt_script+3);

			set_dack8(dack_live, dack_script);
			set_dsn4(dsn_live, dsn_script);
			set_ssn_dll_cs(ssn_live,
			               ((mp_state.idsn >>32)<<32) + ntohl(dsn_live->dsn4),
			               subflow->ssn,
			               tcp_payload_length,
			               dss_opt_script->length == TCPOLEN_DSS_DACK8_DSN4);

		// DSN8 & DACK4
		} else if (dss_opt_script->data.dss.flag_m &&
			   !dss_opt_script->data.dss.flag_a) {
			// get original information from live_packet
			struct dack *dack_live	= (struct dack*)((u32*)dss_opt_live+1);
			struct dsn *dsn_live 	= (struct dsn*)((u32*)dss_opt_live+2);
			u32* ssn_live           = (u32*)dsn_live+2;
			struct dack *dack_script= (struct dack*)((u32*)dss_opt_script+1);
			struct dsn *dsn_script	= (struct dsn*)((u32*)dss_opt_script+2);

			set_dack4(dack_live, dack_script);
			set_dsn8(dsn_live, dsn_script);
			set_ssn_dll_cs(ssn_live,
			               dsn_live->dsn8,
			               subflow->ssn,
			               tcp_payload_length,
			               dss_opt_script->length == TCPOLEN_DSS_DACK4_DSN8);

		// DSN8 & DACK8
		}else if(dss_opt_script->data.dss.flag_m && dss_opt_script->data.dss.flag_a){
			// get original information from live_packet
			struct dack *dack_live	= (struct dack*)((u32*)dss_opt_live+1);
			struct dsn *dsn_live 	= (struct dsn*)((u32*)dss_opt_live+3);
			u32* ssn_live           = (u32*)dsn_live+2;
			struct dack *dack_script= (struct dack*)((u32*)dss_opt_script+1);
			struct dsn *dsn_script	= (struct dsn*)((u32*)dss_opt_script+3);

			set_dack8(dack_live, dack_script);
			set_dsn8(dsn_live, dsn_script);
			set_ssn_dll_cs(ssn_live,
			               dsn_live->dsn8,
			               subflow->ssn,
			               tcp_payload_length,
			               dss_opt_script->length == TCPOLEN_DSS_DACK8_DSN8);
		}
	// IF DSN only
	}else if(dss_opt_script->data.dss.flag_M){
		struct dsn *dsn_live 	= (struct dsn*)((u32*)dss_opt_live+1);
		struct dsn *dsn_script	= (struct dsn*)((u32*)dss_opt_script+1);

		//DSN4
		if(!dss_opt_script->data.dss.flag_m){
			u32* ssn_live           = (u32*)dsn_live+1;

			set_dsn4(dsn_live, dsn_script);
			set_ssn_dll_cs(ssn_live,
			               ((mp_state.idsn >>32)<<32) + ntohl(dsn_live->dsn4),
			               subflow->ssn,
			               tcp_payload_length,
			               dss_opt_script->length == TCPOLEN_DSS_DSN4);

		//DSN8
		}else{
			u32* ssn_live           = (u32*)dsn_live+2;

			set_dsn8(dsn_live, dsn_script);
			set_ssn_dll_cs(ssn_live,
			               dsn_live->dsn8,
			               subflow->ssn,
			               tcp_payload_length,
			               dss_opt_script->length == TCPOLEN_DSS_DSN8);
		}
	}
	// IF ACK only
	else if(dss_opt_script->data.dss.flag_A){
		// get original information from live_packet
		struct dack *dack_live	= (struct dack*)((u32*)dss_opt_live+1);
		struct dack *dack_script= (struct dack*)((u32*)dss_opt_script+1);

		if(!dss_opt_script->data.dss.flag_a)
			set_dack4(dack_live, dack_script);
		else
			set_dack8(dack_live, dack_script);
	}
	subflow->ssn += tcp_payload_length;
	return STATUS_OK;
}

int dss_outbound_parser(struct packet *packet_to_modify,
		struct packet *live_packet,
		struct tcp_option *dss_opt_script){

	struct tcp_option* dss_opt_live = get_mptcp_option(live_packet, DSS_SUBTYPE);
	if(!dss_opt_live)
		return STATUS_ERR;

	// if a packet is coming from kernel with DSN and DACK
	if(dss_opt_script->data.dss.flag_M && dss_opt_script->data.dss.flag_A){

		// DSN4 & DACK4
		if(!dss_opt_script->data.dss.flag_m && !dss_opt_script->data.dss.flag_a){
			if(!(!dss_opt_live->data.dss.flag_m && !dss_opt_live->data.dss.flag_a))
				return STATUS_ERR;

			// get original information from live_packet
			u32 *dack_live			= (u32*)dss_opt_live+1;
			u32 *dsn_live			= (u32*)dack_live+1;
			u32 *ssn_live			= (u32*)dsn_live+1;

			int *dack_script = (int*)dss_opt_script+1;
			int *dsn_script = (int*)dack_script+1;
			int *ssn_script = (int*)dsn_script+1;
			s16 *dll_script = (s16*)ssn_script+2;
			s16 *chk_script = (s16*)ssn_script+3;
		/*	printf("1264: dack4: %d, dsn4: %d, ssn: %d; dll: %d, chk: %d;\n",
					*dack_script,
					*dsn_script,
					*ssn_script,
					*dll_script,
					*chk_script); */

			// put information in dack option of script packet
			if(*dack_script == UNDEFINED){
				*dack_script = *dack_live;
			}else if(*dack_script == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				*dack_script =
					htonl(sha_least_64bits(*key,
							       mp_state.hash) +
					      additional_val);
			}else{
				if (*dack_script > 0) {
					*dack_script =
						htonl(sha_least_64bits(mp_state.packetdrill_key,
								       mp_state.hash) +
						      *dack_script);
				}
			}

			//Set dsn being value specified in script
			if(*dsn_script == UNDEFINED){
				*dsn_script 		= *dsn_live;
			}else if(*dsn_script == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key 			= find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				*dsn_script =
				      htonl(sha_least_64bits(*key,
							     mp_state.hash) +
					    additional_val);
			}else{
				if (*dsn_script > 0) {
					*dsn_script =
						htonl(sha_least_64bits(mp_state.kernel_key,
								       mp_state.hash) +
						      *dsn_script);
				}
			}

			// put ssn from live packet
			if(*ssn_script == UNDEFINED)
				*ssn_script = *ssn_live;
			else
				*ssn_script = htonl(*ssn_script);

			// put dll from live packet
			if(*dll_script == UNDEFINED)
				*dll_script = (u16)*((u16*)ssn_live + 2);
			else
				*dll_script = htons(*dll_script);

			// put checksum from live packet or script packet;
			if(*chk_script == UNDEFINED)
				*chk_script = (u16)*((u16*)ssn_live + 3);
			else
				*chk_script = htons(*chk_script);

			mp_state.remote_last_pkt_length = ntohs(*dll_script);
			if(dss_opt_live->data.dss.flag_F)
				mp_state.remote_last_pkt_length++;
			mp_state.remote_ssn = ntohl(*ssn_script);

			// DSN4 & DACK8
		}else if(!dss_opt_script->data.dss.flag_m && dss_opt_script->data.dss.flag_a){
			if(!(!dss_opt_live->data.dss.flag_m && dss_opt_live->data.dss.flag_a))
				return STATUS_ERR;
			// get original information from live_packet
			u64 *dack_live			= (u64 *)((u32 *)dss_opt_live + 1);
			u32 *dsn_live			= (u32*)dack_live+2;
			u32 *ssn_live			= (u32*)dsn_live+1;

			int *dack_script 	= (int*)dss_opt_script+1;
			int *dsn_script 	= (int*)dack_script+2;
			int *ssn_script 	= (int*)dsn_script+1;
			s16 *dll_script 	= (s16*)ssn_script+2;
			s16 *chk_script 	= (s16*)ssn_script+3;

			// put information in dack option of script packet
			if(*dack_script == UNDEFINED){
				*dack_script = *dack_live;
			}else if(*dack_script == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				*dack_script =
					htonll(sha_least_64bits(*key,
								mp_state.hash) +
					       additional_val);
			}else{
				if (*dack_script > 0) {
					*dack_script =
						htonll(sha_least_64bits(mp_state.packetdrill_key,
								        mp_state.hash) +
						       *dack_script);
				}
			}

			//Set dsn being value specified in script
			if(*dsn_script == UNDEFINED){
				*dsn_script 		= *dsn_live;
			}else if(*dsn_script == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key 			= find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				*dsn_script =
					htonl(sha_least_64bits(*key,
							       mp_state.hash) +
					      additional_val);
			}else{
				if (*dsn_script > 0) {
					*dsn_script =
						htonl(sha_least_64bits(mp_state.kernel_key,
								       mp_state.hash) +
						      *dsn_script);
				}
			}

			// put ssn from live packet
			if(*ssn_script == UNDEFINED)
				*ssn_script = *ssn_live;
			else
				*ssn_script = htonl(*ssn_script);

			// put dll from live packet
			if(*dll_script == UNDEFINED)
				*dll_script = (u16)*((u16*)ssn_live + 2);
			else
				*dll_script = htons(*dll_script);

			// put checksum from live packet or script packet;
			if(*chk_script == UNDEFINED)
				*chk_script = (u16)*((u16*)ssn_live + 3);
			else
				*chk_script = htons(*chk_script);

			mp_state.remote_last_pkt_length = ntohs(*dll_script);
			if(dss_opt_live->data.dss.flag_F)
				mp_state.remote_last_pkt_length++;
			mp_state.remote_ssn = ntohl(*ssn_script);

			// DSN8 & DACK4
		}else if(dss_opt_script->data.dss.flag_m && !dss_opt_script->data.dss.flag_a){
			if(!(dss_opt_live->data.dss.flag_m && !dss_opt_live->data.dss.flag_a))
				return STATUS_ERR;

			// get original information from live_packet
			u32 *dack_live			= (u32*)dss_opt_live+1;
			u64 *dsn_live			= (u64 *)((u32 *)dack_live + 1);
			u32 *ssn_live			= (u32*)dsn_live+2;

			u32 *dack_script = (u32 *)dss_opt_script + 1;
			u64 *dsn_script = (u64 *)((u32 *)dack_script + 1);
			int *ssn_script = (int*)dsn_script+2;
			s16 *dll_script = (s16*)ssn_script+2;
			s16 *chk_script = (s16*)ssn_script+3;

			// put information in dack option of script packet
			if(*dack_script == UNDEFINED){
				*dack_script = *dack_live;
			}else if(*dack_script == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				*dack_script =
					htonl(sha_least_64bits(*key,
							       mp_state.hash) +
					      additional_val);
			}else{
				if (*dack_script > 0){
					*dack_script =
						htonl(sha_least_64bits(mp_state.packetdrill_key,
								       mp_state.hash) +
						      *dack_script);
				}
			}

			//Set dsn being value specified in script
			if(*dsn_script == UNDEFINED){
				*dsn_script 		= *dsn_live;
			}else if(*dsn_script == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key 			= find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				*dsn_script = htonll(sha_least_64bits(*key,
								      mp_state.hash) +
					      additional_val);
			}else{
				if(*dsn_script > 0){
					*dsn_script =
						htonll(sha_least_64bits(mp_state.kernel_key,
								        mp_state.hash) +
						       *dsn_script);
				}
			}

			// put ssn from live packet
			if(*ssn_script == UNDEFINED)
				*ssn_script = *ssn_live;
			else
				*ssn_script = htonl(*ssn_script);

			// put dll from live packet
			if(*dll_script == UNDEFINED)
				*dll_script = (u16)*((u16*)ssn_live + 2);
			else
				*dll_script = htons(*dll_script);

			// put checksum from live packet or script packet;
			if(*chk_script == UNDEFINED)
				*chk_script = (u16)*((u16*)ssn_live + 3);
			else
				*chk_script = htons(*chk_script);

			mp_state.remote_last_pkt_length = ntohs(*dll_script);
			if(dss_opt_live->data.dss.flag_F)
				mp_state.remote_last_pkt_length++;
			mp_state.remote_ssn = ntohl(*ssn_script);

		// DSN8 & DACK8
		}else if(dss_opt_script->data.dss.flag_m && dss_opt_script->data.dss.flag_a){
			if(!(dss_opt_script->data.dss.flag_m && dss_opt_script->data.dss.flag_a))
				return STATUS_ERR;

			// get original information from live_packet
			u64 *dack_live			= (u64 *)((u32 *)dss_opt_live + 1);
			u64 *dsn_live			= (u64 *)((u32 *)dack_live + 2);
			u32 *ssn_live			= (u32*)dsn_live+2;

			u64 *dack_script = (u64 *)((u32 *)dss_opt_script + 1);
			u64 *dsn_script = (u64 *)((u32 *)dack_script + 2);
			int *ssn_script = (int*)dsn_script+2;
			s16 *dll_script = (s16*)ssn_script+2;
			s16 *chk_script = (s16*)ssn_script+3;

			// put information in dack option of script packet
			if(*dack_script == UNDEFINED){
				*dack_script = *dack_live;
			}else if(*dack_script == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				*dack_script =
					htonll(sha_least_64bits(*key,
								mp_state.hash) +
					       additional_val);
			}else{
				if (*dack_script > 0) {
					*dack_script =
						htonll(sha_least_64bits(mp_state.packetdrill_key,
								        mp_state.hash) +
						       *dack_script);
				}
			}

			//Set dsn being value specified in script
			if(*dsn_script == UNDEFINED){
				*dsn_script 		= *dsn_live;
			}else if(*dsn_script == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key 			= find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				*dsn_script =
					htonll(sha_least_64bits(*key,
								mp_state.hash) +
					       additional_val);
			}else{
				if (*dsn_script > 0) {
					*dsn_script =
						htonll(sha_least_64bits(mp_state.kernel_key,
								        mp_state.hash) +
						       *dsn_script);
				}
			}

						// put ssn from live packet
			if(*ssn_script == UNDEFINED)
				*ssn_script = *ssn_live;
			else
				*ssn_script = htonl(*ssn_script);

			// put dll from live packet
			if(*dll_script == UNDEFINED)
				*dll_script = (u16)*((u16*)ssn_live + 2);
			else
				*dll_script = htons(*dll_script);

			// put checksum from live packet or script packet;
			if(*chk_script == UNDEFINED)
				*chk_script = (u16)*((u16*)ssn_live + 3);
			else
				*chk_script = htons(*chk_script);

			mp_state.remote_last_pkt_length = ntohs(*dll_script);
			if(dss_opt_live->data.dss.flag_F)
				mp_state.remote_last_pkt_length++;
			mp_state.remote_ssn = ntohl(*ssn_script);

		}else{
			// It means we have a difference of flags about what we waited for
			return STATUS_ERR;
		}

	// Only DSN is in the packet
	}else if(dss_opt_script->data.dss.flag_M ){ // DSS, To verify
		if(!dss_opt_script->data.dss.flag_M)
			return STATUS_ERR;

		// get original dsn from live_packet
		struct dsn *dsn_live 	= (struct dsn*)((u32*)dss_opt_live+1);

		// if DSN is 8 octets
		if(dss_opt_script->data.dss.flag_m){

			// get ssn, dll, and checksum from live_packet
			u32 ssn 	= *((u32*)dsn_live + 1);
			u32 dll_chk = (u32)*((u32*)dsn_live + 3);
			u16 dll 	= (u16)dll_chk;
			u16 chk 	= dll_chk >> 16;

			// if dsn8 is not given in the script, we'll put it automatically
			if(dss_opt_script->data.dss.dsn.dsn8 == UNDEFINED)
				dss_opt_script->data.dss.dsn.dsn8 = dsn_live->dsn8; //htobe64
			else if(dss_opt_script->data.dss.dsn.dsn8 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dss_opt_script->data.dss.dsn.dsn8 =
					htonll(sha_least_64bits(*key,
					       mp_state.hash) +
					additional_val);
			}else{
				if (dss_opt_script->data.dss.dsn.dsn8 > 0) {
					dss_opt_script->data.dss.dsn.dsn8 =
						htonll(sha_least_64bits(mp_state.kernel_key,
									mp_state.hash) +
						       dss_opt_script->data.dss.dsn.dsn8);
				}
			}

			if(dss_opt_script->length == TCPOLEN_DSS_DSN8){
				dss_opt_script->data.dss.dsn.w_cs.dll =	dll;
				dss_opt_script->data.dss.dsn.w_cs.ssn = ssn;
				dss_opt_script->data.dss.dsn.w_cs.checksum = chk;
			}/*else{
				dss_opt_script->data.dss.dsn.wo_cs.dll =	dll;
				dss_opt_script->data.dss.dsn.wo_cs.ssn = ssn;
			} WOCS*/
			mp_state.remote_last_pkt_length = ntohs(dll);
			if(dss_opt_live->data.dss.flag_F)
				mp_state.remote_last_pkt_length++;
			mp_state.remote_ssn = ntohl(ssn);
		}
		// if DSN is 4 octets
		else {
			// get ssn, dll, and checksum from live_packet
			u32 ssn 	= *((u32*)dsn_live + 1);
			u32 dll_chk = (u32)*((u32*)dsn_live + 2);
			u16 dll 	= (u16)dll_chk;
//			u16 chk 	= dll_chk >> 16;

			// if dsn8 is not given in the script, we'll put it automatically
			if(dss_opt_script->data.dss.dsn.dsn4 == UNDEFINED)
				dss_opt_script->data.dss.dsn.dsn4 = dsn_live->dsn4;
			else if(dss_opt_script->data.dss.dsn.dsn4 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dss_opt_script->data.dss.dsn.dsn4 =
					htobe32(sha_least_64bits(*key,
								 mp_state.hash) +
						additional_val);
			}else{
				if (dss_opt_script->data.dss.dsn.dsn4 >0) {
					dss_opt_script->data.dss.dsn.dsn4 =
						htonll(sha_least_64bits(mp_state.kernel_key,
								        mp_state.hash) +
						       dss_opt_script->data.dss.dsn.dsn4);
				}
			}
			u32 *script_dsn4 	= (u32*)dss_opt_script+3;
			// put ssn, dll, chk in script_packet
			u32 *script_ssn 		= (u32*)((u32*)script_dsn4 + 1);
			*script_ssn 			= ssn;
			u32 *script_dll_chk 	= script_ssn + 1;
			*script_dll_chk 		= dll_chk;
			mp_state.remote_last_pkt_length = ntohs(dll);
			if(dss_opt_live->data.dss.flag_F)
				mp_state.remote_last_pkt_length++;
			mp_state.remote_ssn = ntohl(ssn);
		}

	// if it's DACK only from kernel, need to save it
	}else if(dss_opt_script->data.dss.flag_A ){
		if(!dss_opt_script->data.dss.flag_A)
			return STATUS_ERR;

		// get original dack from live_packet
		struct dack *dack_live 	= (struct dack*)((u32*)dss_opt_live+1);

		// if DACK is 8 octets
		if(dss_opt_script->data.dss.flag_a){

			// if dack8 is not given in the script, we'll put it automatically
			if(dss_opt_script->data.dss.dack.dack8 == UNDEFINED)
				dss_opt_script->data.dss.dack.dack8 = dack_live->dack8;
			else if(dss_opt_script->data.dss.dack.dack8 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dss_opt_script->data.dss.dack.dack8 =
					htonll(sha_least_64bits(*key,
								mp_state.hash) +
					       additional_val);
			}else{
				if (dss_opt_script->data.dss.dack.dack8 > 0){
					dss_opt_script->data.dss.dack.dack8 =
						htonll(sha_least_64bits(mp_state.packetdrill_key,
									mp_state.hash) +
						       dss_opt_script->data.dss.dack.dack8);
				}
			}
		}
		// if DACK is 4 octets
		else {
			// if dack4 is not given in the script, we'll put it automatically
			if(dss_opt_script->data.dss.dack.dack4 == UNDEFINED)
				dss_opt_script->data.dss.dack.dack4 = dack_live->dack4;
			else if(dss_opt_script->data.dss.dack.dack4==SCRIPT_DEFINED){
				u64 *key = find_next_key();
				if(!key)
					return STATUS_ERR;
				dss_opt_script->data.dss.dack.dack4 = htobe32((u32)*key);
			}else if(dss_opt_script->data.dss.dack.dack4 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dss_opt_script->data.dss.dack.dack4 =
					htonl(sha_least_64bits(*key,
							       mp_state.hash) +
					      additional_val);
			}else{
				if (dss_opt_script->data.dss.dack.dack4 > 0) {
					dss_opt_script->data.dss.dack.dack4 =
						htonl(sha_least_64bits(mp_state.packetdrill_key,
								       mp_state.hash) +
						      dss_opt_script->data.dss.dack.dack4);
				}
			}
		}
	}else
		return STATUS_ERR;

	return STATUS_OK;
}


int mptcp_subtype_dss(struct packet *packet_to_modify,
						struct packet *live_packet,
						struct tcp_option *tcp_opt_to_modify,
						unsigned direction){
	int error = -1;
	// injecting a packet to kernel
	if(direction == DIRECTION_INBOUND){
		error = dss_inbound_parser(packet_to_modify, live_packet, tcp_opt_to_modify);
	}else if(direction == DIRECTION_OUTBOUND){
		error = dss_outbound_parser(packet_to_modify, live_packet, tcp_opt_to_modify);
	}
	if(error!=STATUS_OK)
		return STATUS_ERR;

	return STATUS_OK;
}

static int add_addr_family(int optlen)
{
	if(optlen == TCPOLEN_ADD_ADDR_V4 || optlen == TCPOLEN_ADD_ADDR_V4_PORT ||
	   optlen == TCPOLEN_ADD_ADDR_V4_HMAC || optlen == TCPOLEN_ADD_ADDR_V4_PORT_HMAC){
		return AF_INET;
	} else {
		return AF_INET6;
	}
}

static struct endpoint *find_next_addr_outbound(struct packet *live_packet, struct tcp_option *add_addr_script)
{
	struct tcp_option* add_addr_live = get_mptcp_option(live_packet, ADD_ADDR_SUBTYPE);
	struct endpoint *endpoint = NULL;
	char *var_name;
	if(dequeue_var(&var_name) || !var_name)
		return NULL;
	struct mp_var *var = find_mp_var(var_name);
	if(var && var->mptcp_subtype == ADD_ADDR_SUBTYPE)
		endpoint = (struct endpoint*)var->value;
	if(endpoint == NULL){
		struct endpoint live_endpoint;
		memset(&live_endpoint, 0, sizeof(live_endpoint));
		live_endpoint.ip.address_family = add_addr_family(add_addr_live->length);
		if(live_endpoint.ip.address_family == AF_INET)
			live_endpoint.ip.ip.v4 = add_addr_live->data.add_addr.ipv4;
		else
			live_endpoint.ip.ip.v6 = add_addr_live->data.add_addr.ipv6;
		add_mp_var_addr(var_name, &live_endpoint);
		var = find_mp_var(var_name);
		endpoint = (struct endpoint*)var->value;
	}
	free(var_name);
	// the port may be updated for an existing endpoint
	if(add_addr_script->length == TCPOLEN_ADD_ADDR_V4 ||
	   add_addr_script->length == TCPOLEN_ADD_ADDR_V4_HMAC ||
	   add_addr_script->length == TCPOLEN_ADD_ADDR_V6 ||
	   add_addr_script->length == TCPOLEN_ADD_ADDR_V6_HMAC){
		struct tuple tuple;
		get_packet_tuple(live_packet, &tuple);
		endpoint->port = tuple.src.port;
	}else if(add_addr_script->length == TCPOLEN_ADD_ADDR_V4_PORT ||
		 add_addr_script->length == TCPOLEN_ADD_ADDR_V4_PORT_HMAC){
		if(add_addr_script->data.add_addr.ipv4_w_port.port == UNDEFINED)
			endpoint->port = add_addr_live->data.add_addr.ipv4_w_port.port;
		else
			endpoint->port = add_addr_script->data.add_addr.ipv4_w_port.port;
	}else if(add_addr_script->length == TCPOLEN_ADD_ADDR_V6_PORT ||
		 add_addr_script->length == TCPOLEN_ADD_ADDR_V6_PORT_HMAC){
		if(add_addr_script->data.add_addr.ipv6_w_port.port == UNDEFINED)
			endpoint->port = add_addr_live->data.add_addr.ipv6_w_port.port;
		else
			endpoint->port = add_addr_script->data.add_addr.ipv6_w_port.port;
	}
	return endpoint;
}

static struct endpoint *find_next_addr_inbound(struct packet *live_packet, struct tcp_option *add_addr_script,
					       struct mp_subflow *subflow)
{
	struct tcp_option* add_addr_live = get_mptcp_option(live_packet, ADD_ADDR_SUBTYPE);
	u8 address_id = add_addr_script->data.add_addr.address_id;
	char *var_name;
	if(dequeue_var(&var_name) || !var_name)
		return NULL;
	struct endpoint *endpoint = NULL;
	struct mp_var *var = find_mp_var(var_name);
	if(var && var->mptcp_subtype == ADD_ADDR_SUBTYPE)
		endpoint = (struct endpoint*)var->value;
	if(endpoint == NULL){
		struct ip_address *ip = NULL;
		find_or_create_packetdrill_addr(&address_id, &ip);
		struct endpoint packetdrill_endpoint;
		memcpy(&packetdrill_endpoint.ip, ip, sizeof(*ip));
		add_mp_var_addr(var_name, &packetdrill_endpoint);
	}else{
		struct ip_address *ip = NULL;
		find_or_create_packetdrill_addr(&address_id, &ip);
	}
	var = find_mp_var(var_name);
	free(var_name);
	if(!var || var->mptcp_subtype != ADD_ADDR_SUBTYPE)
		return NULL;
	endpoint = (struct endpoint*)var->value;
	// the port may be updated for an existing endpoint
	if(add_addr_live->length == TCPOLEN_ADD_ADDR_V4 ||
	   add_addr_live->length == TCPOLEN_ADD_ADDR_V4_HMAC ||
	   add_addr_live->length == TCPOLEN_ADD_ADDR_V6 ||
	   add_addr_live->length == TCPOLEN_ADD_ADDR_V6_HMAC){
		endpoint->port = htons(subflow->src_port);
	}else if(add_addr_live->length == TCPOLEN_ADD_ADDR_V4_PORT ||
		 add_addr_live->length == TCPOLEN_ADD_ADDR_V4_PORT_HMAC){
		if(add_addr_script->data.add_addr.ipv4_w_port.port == UNDEFINED)
			endpoint->port = htons(subflow->src_port);
		else
			endpoint->port = add_addr_script->data.add_addr.ipv4_w_port.port;
	}else if(add_addr_live->length == TCPOLEN_ADD_ADDR_V6_PORT ||
		 add_addr_live->length == TCPOLEN_ADD_ADDR_V6_PORT_HMAC){
		if(add_addr_script->data.add_addr.ipv6_w_port.port == UNDEFINED)
			endpoint->port = htons(subflow->src_port);
		else
			endpoint->port = add_addr_script->data.add_addr.ipv6_w_port.port;
	}
	return endpoint;
}

static u64 add_addr_ipv4_hmac(u64 key1, u64 key2, u8 address_id, struct in_addr* address, u16 port)
{
	//Build key for HMAC-SHA256
	unsigned char hmac_key[16];
	unsigned long *key_a = (unsigned long*)hmac_key;
	unsigned long *key_b = (unsigned long*)&(hmac_key[8]);
	*key_a = key1;
	*key_b = key2;

	//Build message for HMAC-SHA256
	u8 msg[7];
	msg[0] = address_id;
        memcpy(&msg[1], address, 4);
        msg[5] = port >> 8;
        msg[6] = port & 0xff;

        return hmac_sha256_truncat_most_64(hmac_key, 16, msg, 7);
}

static u64 add_addr_ipv6_hmac(u64 key1, u64 key2, u8 address_id, struct in6_addr* address, u16 port)
{
	//Build key for HMAC-SHA256
	unsigned char hmac_key[16];
	unsigned long *key_a = (unsigned long*)hmac_key;
	unsigned long *key_b = (unsigned long*)&(hmac_key[8]);
	*key_a = key1;
	*key_b = key2;

	//Build message for HMAC-SHA256
	u8 msg[19];
	msg[0] = address_id;
        memcpy(&msg[1], address, 16);
        msg[17] = port >> 8;
        msg[18] = port & 0xff;

        return hmac_sha256_truncat_most_64(hmac_key, 16, msg, 19);
}

int mptcp_subtype_add_address(struct packet *packet_to_modify,
		struct packet *live_packet,
		struct tcp_option *add_addr_script,
		unsigned direction)
{
	struct tcp_option* add_addr_live = get_mptcp_option(live_packet, ADD_ADDR_SUBTYPE);
	if(!add_addr_live)
		return STATUS_ERR;

	if(direction == DIRECTION_INBOUND){
		struct mp_subflow *subflow = find_subflow_matching_inbound_packet(packet_to_modify);
		if(!subflow)
			return STATUS_ERR;

		struct endpoint *endpoint = find_next_addr_inbound(live_packet, add_addr_script, subflow);
		if(endpoint == NULL)
			return STATUS_ERR;

		if((s8)add_addr_script->data.add_addr.address_id == UNDEFINED){
			struct mp_address *addr;
			for(addr = mp_state.packetdrill_addrs; addr; addr = addr->next)
				if(is_equal_ip(&addr->ip, &endpoint->ip))
					break;
			add_addr_live->data.add_addr.address_id = addr->addr_id;
		}

		if(add_addr_live->length == TCPOLEN_ADD_ADDR_V4){
			add_addr_live->data.add_addr.ipv4 = endpoint->ip.ip.v4;
		}else if(add_addr_live->length == TCPOLEN_ADD_ADDR_V4_PORT){
			add_addr_live->data.add_addr.ipv4_w_port.ipv4 = endpoint->ip.ip.v4;
			if(add_addr_script->data.add_addr.ipv4_w_port.port == UNDEFINED)
				add_addr_live->data.add_addr.ipv4_w_port.port = endpoint->port;
		}else if(add_addr_live->length == TCPOLEN_ADD_ADDR_V4_HMAC){
			add_addr_live->data.add_addr.ipv4_w_hmac.ipv4 = endpoint->ip.ip.v4;
			if(add_addr_script->data.add_addr.ipv4_w_hmac.hmac == UNDEFINED)
				add_addr_live->data.add_addr.ipv4_w_hmac.hmac =
                                        add_addr_ipv4_hmac(mp_state.packetdrill_key,
                                                           mp_state.kernel_key,
                                                           add_addr_script->data.add_addr.address_id,
                                                           &add_addr_script->data.add_addr.ipv4_w_hmac.ipv4,
                                                           0);
		}else if(add_addr_live->length == TCPOLEN_ADD_ADDR_V4_PORT_HMAC){
			add_addr_live->data.add_addr.ipv4_w_port_hmac.ipv4 = endpoint->ip.ip.v4;
			if(add_addr_script->data.add_addr.ipv4_w_port_hmac.port == UNDEFINED)
				add_addr_live->data.add_addr.ipv4_w_port_hmac.port = endpoint->port;
			if(add_addr_script->data.add_addr.ipv4_w_port_hmac.hmac == UNDEFINED)
				add_addr_live->data.add_addr.ipv4_w_port_hmac.hmac =
                                        add_addr_ipv4_hmac(mp_state.packetdrill_key,
                                                           mp_state.kernel_key,
                                                           add_addr_script->data.add_addr.address_id,
                                                           &add_addr_script->data.add_addr.ipv4_w_port_hmac.ipv4,
                                                           0);
		}else if(add_addr_live->length == TCPOLEN_ADD_ADDR_V6){
			add_addr_live->data.add_addr.ipv6 = endpoint->ip.ip.v6;
		}else if(add_addr_live->length == TCPOLEN_ADD_ADDR_V6_PORT){
			add_addr_script->data.add_addr.ipv6_w_port.ipv6 = endpoint->ip.ip.v6;
			if(add_addr_script->data.add_addr.ipv6_w_port.port == UNDEFINED)
				add_addr_live->data.add_addr.ipv6_w_port.port = endpoint->port;
		}else if(add_addr_live->length == TCPOLEN_ADD_ADDR_V6_HMAC){
			add_addr_script->data.add_addr.ipv6_w_hmac.ipv6 = endpoint->ip.ip.v6;
			if(add_addr_script->data.add_addr.ipv6_w_hmac.hmac == UNDEFINED)
				add_addr_live->data.add_addr.ipv6_w_hmac.hmac =
                                        add_addr_ipv6_hmac(mp_state.packetdrill_key,
                                                           mp_state.kernel_key,
                                                           add_addr_script->data.add_addr.address_id,
                                                           &add_addr_script->data.add_addr.ipv6_w_hmac.ipv6,
                                                           0);
		}else if(add_addr_live->length == TCPOLEN_ADD_ADDR_V6_PORT_HMAC){
			add_addr_script->data.add_addr.ipv6_w_port_hmac.ipv6 = endpoint->ip.ip.v6;
			if(add_addr_script->data.add_addr.ipv6_w_port_hmac.port == UNDEFINED)
				add_addr_live->data.add_addr.ipv6_w_port_hmac.port = endpoint->port;
			if(add_addr_script->data.add_addr.ipv6_w_port_hmac.hmac == UNDEFINED)
				add_addr_live->data.add_addr.ipv6_w_port_hmac.hmac =
                                        add_addr_ipv6_hmac(mp_state.packetdrill_key,
                                                           mp_state.kernel_key,
                                                           add_addr_script->data.add_addr.address_id,
                                                           &add_addr_script->data.add_addr.ipv6_w_port_hmac.ipv6,
                                                           0);
		}else
			return STATUS_ERR;
	}else if(direction == DIRECTION_OUTBOUND){
		struct endpoint *endpoint = find_next_addr_outbound(live_packet, add_addr_script);
		if(endpoint == NULL)
			return STATUS_ERR;

		if((s8)add_addr_script->data.add_addr.address_id == UNDEFINED)
			add_addr_script->data.add_addr.address_id = add_addr_live->data.add_addr.address_id;

		if(add_addr_script->length == TCPOLEN_ADD_ADDR_V4){
			add_addr_script->data.add_addr.ipv4 = endpoint->ip.ip.v4;
		}else if(add_addr_script->length == TCPOLEN_ADD_ADDR_V4_PORT){
			add_addr_script->data.add_addr.ipv4_w_port.ipv4 = endpoint->ip.ip.v4;
			if(add_addr_script->data.add_addr.ipv4_w_port.port == UNDEFINED)
				add_addr_script->data.add_addr.ipv4_w_port.port = endpoint->port;
		}else if(add_addr_script->length == TCPOLEN_ADD_ADDR_V4_HMAC){
			add_addr_script->data.add_addr.ipv4_w_hmac.ipv4 = endpoint->ip.ip.v4;
			if(add_addr_script->data.add_addr.ipv4_w_hmac.hmac == UNDEFINED)
				add_addr_script->data.add_addr.ipv4_w_hmac.hmac =
                                        add_addr_ipv4_hmac(mp_state.kernel_key,
                                                           mp_state.packetdrill_key,
                                                           add_addr_live->data.add_addr.address_id,
                                                           &add_addr_live->data.add_addr.ipv4_w_hmac.ipv4,
                                                           0);
		}else if(add_addr_script->length == TCPOLEN_ADD_ADDR_V4_PORT_HMAC){
			add_addr_script->data.add_addr.ipv4_w_port_hmac.ipv4 = endpoint->ip.ip.v4;
			if(add_addr_script->data.add_addr.ipv4_w_port.port == UNDEFINED)
				add_addr_script->data.add_addr.ipv4_w_port.port = endpoint->port;
			if(add_addr_script->data.add_addr.ipv4_w_port_hmac.hmac == UNDEFINED)
				add_addr_script->data.add_addr.ipv4_w_port_hmac.hmac =
                                        add_addr_ipv4_hmac(mp_state.kernel_key,
                                                           mp_state.packetdrill_key,
                                                           add_addr_live->data.add_addr.address_id,
                                                           &add_addr_live->data.add_addr.ipv4_w_port_hmac.ipv4,
                                                           0);
		}else if(add_addr_script->length == TCPOLEN_ADD_ADDR_V6){
			add_addr_script->data.add_addr.ipv6 = endpoint->ip.ip.v6;
		}else if(add_addr_script->length == TCPOLEN_ADD_ADDR_V6_PORT){
			add_addr_script->data.add_addr.ipv6_w_port.ipv6 = endpoint->ip.ip.v6;
			if(add_addr_script->data.add_addr.ipv6_w_port.port == UNDEFINED)
				add_addr_script->data.add_addr.ipv6_w_port.port = endpoint->port;
		}else if(add_addr_script->length == TCPOLEN_ADD_ADDR_V6_HMAC){
			add_addr_script->data.add_addr.ipv6_w_hmac.ipv6 = endpoint->ip.ip.v6;
			if(add_addr_script->data.add_addr.ipv6_w_hmac.hmac == UNDEFINED)
				add_addr_script->data.add_addr.ipv6_w_hmac.hmac =
                                        add_addr_ipv6_hmac(mp_state.kernel_key,
                                                           mp_state.packetdrill_key,
                                                           add_addr_live->data.add_addr.address_id,
                                                           &add_addr_live->data.add_addr.ipv6_w_hmac.ipv6,
                                                           0);
		}else if(add_addr_script->length == TCPOLEN_ADD_ADDR_V6_PORT_HMAC){
			add_addr_script->data.add_addr.ipv6_w_port_hmac.ipv6 = endpoint->ip.ip.v6;
			if(add_addr_script->data.add_addr.ipv6_w_port.port == UNDEFINED)
				add_addr_script->data.add_addr.ipv6_w_port.port = endpoint->port;
			if(add_addr_script->data.add_addr.ipv6_w_port_hmac.hmac == UNDEFINED)
				add_addr_script->data.add_addr.ipv6_w_port_hmac.hmac =
                                        add_addr_ipv6_hmac(mp_state.kernel_key,
                                                           mp_state.packetdrill_key,
                                                           add_addr_live->data.add_addr.address_id,
                                                           &add_addr_live->data.add_addr.ipv6_w_port_hmac.ipv6,
                                                           0);
		}else{
			return STATUS_ERR;
		}
	}else{
		return STATUS_ERR;
	}

	return STATUS_OK;
}

int mptcp_subtype_remove_address(struct packet *packet_to_modify,
		struct packet *live_packet,
		struct tcp_option *dss_opt_script,
		unsigned direction)
{
/*	// TODO(reward): complete automatically the field

	u8 *cur_id = (u8*)&dss_opt_script->data.remove_addr.address_id;
	int nb_ids  = dss_opt_script->length - TCPOLEN_REMOVE_ADDR;

//	printf("1822: processing remove_address packet, %d ids, [%u, %u, %u, %u, %u]\n", nb_ids, (unsigned)*cur_id, (unsigned)*(cur_id+1), (unsigned)*(cur_id+2), (unsigned)*(cur_id+3), (unsigned)*(cur_id+4));
*/

	if(direction == DIRECTION_INBOUND){

	}else if(direction == DIRECTION_OUTBOUND){

	}else
		return STATUS_ERR;
	return STATUS_OK;
}

/**
 * Insert appropriate key in mp_fail mptcp option.
 */
int mptcp_subtype_mp_fail(struct packet *packet_to_modify,
		struct packet *live_packet,
		struct tcp_option *dss_opt_script,
		unsigned direction)
{
	struct tcp_option* dss_opt_live = get_tcp_option(live_packet, TCPOPT_MPTCP);
	if(!dss_opt_live)
		return STATUS_ERR;

	// TODO(redward): verify if it really converts correctly the dsn8

	if(direction == DIRECTION_INBOUND){
		u32 bytes_sent_on_all_ssn = get_sum_ssn();

		//Set dsn being value specified in script
		if (dss_opt_script->data.dss.dsn.dsn8 == UNDEFINED)
			dss_opt_script->data.dss.dsn.dsn8 = htonll(mp_state.idsn + bytes_sent_on_all_ssn); //subflow->ssn);
		else if(dss_opt_script->data.dss.dsn.dsn8 == SCRIPT_DEFINED_TO_HASH_LSB){
			u64 additional_val = find_next_value();
			u64 *key = find_next_key();
			if(!key || additional_val == STATUS_ERR)
				return STATUS_ERR;
			dss_opt_script->data.dss.dsn.dsn8 =
				htonll(sha_least_64bits(*key, mp_state.hash) +
				       additional_val);
		}else{
			// this is to get the relative numbers from script
			if(dss_opt_script->data.dss.dsn.dsn8 > 0)
				dss_opt_script->data.dss.dsn.dsn8 =
					htonll(sha_least_64bits(mp_state.packetdrill_key,
								mp_state.hash) +
					       dss_opt_script->data.dss.dsn.dsn8);
		}
	}else if(direction == DIRECTION_OUTBOUND){
		//Set dsn being value specified in script
		if(dss_opt_script->data.mp_fail.dsn8 == UNDEFINED){
			dss_opt_script->data.mp_fail.dsn8 		= dss_opt_live->data.mp_fail.dsn8;
		}else if(dss_opt_script->data.dss.dsn.dsn8  == SCRIPT_DEFINED_TO_HASH_LSB){
			u64 additional_val 	= find_next_value();
			u64 *key 			= find_next_key();
			if(!key || additional_val==STATUS_ERR)
				return STATUS_ERR;
			dss_opt_script->data.dss.dsn.dsn8 =
				htonll(sha_least_64bits(*key, mp_state.hash) + additional_val);
		}else{
			// this is to get the relative numbers from script
			if (dss_opt_script->data.dss.dsn.dsn8 > 0) {
				dss_opt_script->data.dss.dsn.dsn8 =
					htonll(sha_least_64bits(mp_state.kernel_key,
								mp_state.hash) +
					       dss_opt_script->data.dss.dsn.dsn8);
			}
		}
	}else
		return STATUS_ERR;
	return STATUS_OK;
}
/**
 * Insert appropriate key in mp_fastclose mptcp option.
 */
int mptcp_subtype_mp_fastclose(struct packet *packet_to_modify,
		struct packet *live_packet,
		struct tcp_option *dss_opt_script,
		unsigned direction)
{
	struct tcp_option* dss_opt_live = get_mptcp_option(live_packet, MP_FASTCLOSE_SUBTYPE);
	if(!dss_opt_live)
		return STATUS_ERR;

	if(dss_opt_script->data.mp_fastclose.receiver_key == UNDEFINED){ // <mp_fastclose>
		if(direction == DIRECTION_INBOUND)
			dss_opt_script->data.mp_fastclose.receiver_key = htonll(mp_state.kernel_key);
		else if(direction == DIRECTION_OUTBOUND)
			dss_opt_script->data.mp_fastclose.receiver_key = dss_opt_live->data.mp_fastclose.receiver_key;
		else
			return STATUS_ERR;
	}else if(dss_opt_script->data.mp_fastclose.receiver_key == SCRIPT_DEFINED ||
			dss_opt_script->data.mp_fastclose.receiver_key == SCRIPT_ASSIGNED){ //<mp_fastclose b> et b=123
		u64 *key = find_next_key();
		if(!key)
			return STATUS_ERR;
		dss_opt_script->data.mp_fastclose.receiver_key = htonll(*key);
	}else if(dss_opt_script->data.mp_fastclose.receiver_key==MPTCP_KEY){ // <mp_fastclose b + 123>
		u64 additional_val 	= find_next_value();
		u64 *key = find_next_key();
		if(!key || additional_val==STATUS_ERR)
			return STATUS_ERR;
		dss_opt_script->data.mp_fastclose.receiver_key = htonll(*key + additional_val);
	}else
		return STATUS_ERR;

	return STATUS_OK;
}

/**
 * Main function for managing mptcp packets. We have to insert appropriate
 * fields values for mptcp options according to previous state.
 *
 * Some of these values are generated randomly (packetdrill mptcp key,...)
 * others are sniffed from packets sent by the kernel (kernel mptcp key,...).
 * These values have to be inserted some mptcp script and live packets.
 */
int mptcp_insert_and_extract_opt_fields(struct packet *packet_to_modify,
		struct packet *live_packet, // could be the same as packet_to_modify
		unsigned direction)
{

	struct tcp_options_iterator tcp_opt_iter;
	struct tcp_option *tcp_opt_to_modify =
			tcp_options_begin(packet_to_modify, &tcp_opt_iter);
	int error = STATUS_OK;
	while(tcp_opt_to_modify != NULL){
		if(tcp_opt_to_modify->kind == TCPOPT_MPTCP){
			switch(tcp_opt_to_modify->data.mp_capable.subtype){
			case MP_CAPABLE_SUBTYPE:	// 00

				error = mptcp_subtype_mp_capable(packet_to_modify,
						live_packet,
						tcp_opt_to_modify,
						direction);
				break;

			case MP_JOIN_SUBTYPE:		//01
				error = mptcp_subtype_mp_join(packet_to_modify,
						live_packet,
						tcp_opt_to_modify,
						direction);
				break;

			case DSS_SUBTYPE:			//02
				error = mptcp_subtype_dss(packet_to_modify,
						live_packet,
						tcp_opt_to_modify,
						direction);
				break;
			case ADD_ADDR_SUBTYPE: 		//03
				error = mptcp_subtype_add_address(packet_to_modify,
						live_packet,
						tcp_opt_to_modify,
						direction);
				break;
			case REMOVE_ADDR_SUBTYPE:	// 04 TODO(redward): in progress
				/*error = mptcp_subtype_remove_address(packet_to_modify,
						live_packet,
						tcp_opt_to_modify,
						direction); */
				break;
			case MP_PRIO_SUBTYPE: 		// 05 TODO(redward): in progress
				break;
			case MP_FAIL_SUBTYPE: 		// 06 TODO(redward): in progress
				error = mptcp_subtype_mp_fail(packet_to_modify,
						live_packet,
						tcp_opt_to_modify,
						direction);
				break;
			case MP_FASTCLOSE_SUBTYPE:		// 07
				error = mptcp_subtype_mp_fastclose(packet_to_modify,
						live_packet,
						tcp_opt_to_modify,
						direction);
				break;
			}
		}
		tcp_opt_to_modify = tcp_options_next(&tcp_opt_iter, NULL);
	}

	return error;
}
