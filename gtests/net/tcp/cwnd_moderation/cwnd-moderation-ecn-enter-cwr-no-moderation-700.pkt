// Test that if we don't moderate cwnd when ECN sees congestion and reduces cwnd.

`../common/defaults.sh
sysctl -q net.ipv4.tcp_ecn=2    # server agrees to ECN if client proposes it
`

// Establish a connection.
    0 socket(..., SOCK_STREAM, IPPROTO_TCP) = 3
   +0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
   +0 bind(3, ..., ...) = 0
   +0 listen(3, 1) = 0

  +.1 < SEW 0:0(0) win 32792 <mss 1000,nop,nop,sackOK,nop,wscale 7>
   +0 > SE. 0:0(0) ack 1 <mss 1460,nop,nop,sackOK,nop,wscale 8>
  +.1 < [ect1] . 1:1(0) ack 1 win 320
   +0 accept(3, ..., ...) = 4

// Send 4 data segments.
   +0 write(4, ..., 4000) = 4000
   +0 > P. 1:4001(4000) ack 1
+.005 %{ assert tcpi_snd_cwnd == 10, tcpi_snd_cwnd }%

+.095 < [noecn] E. 1:1(0) ack 1001 win 320
+.005 %{
assert tcpi_ca_state == TCP_CA_CWR, tcpi_ca_state

# Since commit 684bad110757 "tcp: use PRR to reduce cwin in CWR state" in Linux 3.7, we use 
# Proportional Reduction Rate (PRR) for CWR. In tcp_cwnd_reduction(), since we have 3 packets in
# flight and ssthresh is 7, we do delta = 4 and sndcnt = min(4, 1) = 1, so cwnd = 3 + 1 = 4.

# Commit 7e901ee7b6ab "tcp: avoid slow start during fast recovery on new losses", changes behavior of the test.
# In net/ipv4/tcp_input.c function tcp_cwnd_reduction(struct sock *sk, int newly_acked_sacked, int newly_lost, int flag)
# with added variable newly_lost we end up in the following else branch:
# else if (flag & FLAG_SND_UNA_ADVANCED && !newly_lost).
# Now sndcnt = sndcnt = min_t(int, delta, max_t(int, tp->prr_delivered - tp->prr_out, newly_acked_sacked) + 1) = 2.
# So cwnd = 3 + 2 = 5.

assert tcpi_snd_cwnd == 5, tcpi_snd_cwnd
}%
